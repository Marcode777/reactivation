<!-- *******IT'S ALL ABOUT COMPONENTS, STATES AND PROPS, and remember that a render can only essentially display 1 parent element, if we want to render multiple parent elements, they have to be wrapped in a div. Remember to use ".bind(this)" when passing functions or methods around. Whenever we're binding a value, we'll also set up a change listener for that, so that it actually changes when the value changes.*******

#1 REACTJS WORKSPACE SETUP   
webpack: Before we used to have to make separate files and then load them onto the html separately on their separate script tags. Now it has evolved into module loading systems. 
So beforehand we install Node.JS, then npm init to get a package.json going and then install webpack. Then npm install -g webpack. Then create webpack.config.js, and inside can be a sample start-up webpack. If it's production, if so then we'll run minification, and we won't do source-mapping, if it's not production, then we'll consider it debugging mode and we'll do inline sourcemaps. Our entry point is, in this case, ./js/scripts.js, this is where we're starting off. Our output is the /js folder.



***Excerpt of advice from YouTube: The easiest way to set up your project is to make a directory tree structure the way it's displayed on his sublime text editor.  If you can't make out the structure, do this:  create your project folder; inside the project folder create a 'src' folder; inside the 'src' folder, create a 'js' folder.  You will now create four files.  Create two empty files,  'package.json' and a 'webpack.config.js', and place them at the top level of your project folder.  Create another empty file, 'index.html' and put it inside your 'src' folder.   Create the last file, 'client.js' and place it inside 'js' folder.

Now advance the video to 3:04 and simply type what you see into your 'client.js' file.  As for the contents of the other three files, you can go to the github repository he listed in the  comments under the video.  Specifically, you will need to access the '1-basic-react' folder to get the contents of each the other three files.  

After you have set up your folders and copied the files, you run 'npm install', then 'webpack',  and the rest of the folders and files will be automatically installed.  At this point you can advance to '2:38' in  the video and continue following along.  Hope this helps you and anyone else who might have the same question.ï»¿***-->


<!--the contents in webpack.config.js are from https://github.com/learncodeacademy/react-js-tutorials/blob/master/1-basic-react/webpack.config.js
the contents from package.json are from https://github.com/learncodeacademy/react-js-tutorials/blob/master/1-basic-react/package.json, the only thing I changed was the name, to "reactivation", for my own work-->
<!-- before, when i ran "npm install", then "webpack", it said "bash webpack command not found" I realized that I had to first "npm install webpack" first, and then run "webpack" and this seemed to work-->
<!-- I can continue onto 2:38 of vid #1 now-->

<!-- so we also ran "webpack -- watcher", which watches our code for changes and as we save, it'll continue to do that. So if you change something in the code and save, it will retranspile everything.-->
<!-- after the comments in client.js, we're back here. So let's wrap up our workspace and our workflow here, obviously we'll want to get some kind of live reload happening, and webpack dev server is kind of the standard way of doing that. So let's go ahead and "npm install -S webpack-dev-server" and let's go ahead and get maybe an npm run dev command going. Well let's also install webpack dev server globally as well, by typing "npm install -g webpack-dev-server" which we won't be using, but we'll do it for now. Let's get webpack-dev-server installed globally so we have the webpack server command. Actually we need to give it a content base. Since we don't want to serve this folder that we're in right now, we want to serve the source folder, we're just going to go content base is source, so we'll type "webpack-dev-server --content-base src" So that way it's going to serve "index.html" as the root of that. So now we can actually go to "localhost 8080". And there we go, we have "localhost8080" working, let's get a split-screen going on, but we don't have live reload up yet. We can do two things, by default we can the iframe mode, which is "localhost:8080/webpack-dev-server/index.html" and you'll see a loader bar up there, it'll automatically load your app into a brand new iframe everytime, so let's change the text, it's going to recompile and reload, so that's kind of smooth. So if that works for us straight out of the bag, that's great. Another thing we can do is we do the inline flag, and hot flag, hot will help it do inline a little bit better as in the console type "webpack-dev-server--content-base src --inline --hot". So if we have inline and hot, then we're not going to have that top, and it's just going to automatically do it inline which is basically live reload. So we're going to go ahead and take that command and we're just going to go ahead and make - that's kind of a mouthful to type everytime, so let's go ahead and add that to our package.json, let's go to our scripts and make it "dev" as in "dev": "webpack-dev-server --content-base src --inline --hot", so there we go, npm run dev now, will run this command for us.
"npm run dev" gets our full webpack-dev-server running, and we're up and rolling! The only the other thing we're going to change is, we don't want to have all our developers have to do an npm install global of webpack-dev-server, so we're actually going to reference the node module's bin, you can see that it installs a command of webpack-dev-server, it installs an executable webpack-dev-server as well, so we can actually execute this command in "dev": "webpack-dev-server --content-base src --inline --hot", with ./ as in "dev": "./node_modules/.bin/webpack-dev-server --content-base src --inline --hot", . That's taken care of by our package now as in "webpack-dev-server": "^1.15.0" in package.json, so now we can actually uninstall, as in "uninstall -g webpack-dev-server", we're going to uninstall that one as in "npm uninstall -g webpack-dev-server", and now npm run dev will still work, because we're referencing the one that's in our repository. So that's a little bit of a cleaner way. At first, with NodeJS, we always had everybody install a global for everything. And now we just think it's much cleaner to install it, with your package, install it locally to your app, that way the exact version you need for your app is installed in your app folder, and then you run it with a node script, npm run dev, or npm start, are kind of the standard choices that you would pick. So there we go, that's running, that's our setup for React.
#2 REACTJS COMPONENTS AND RENDERING 
Again, everything in React is a component. And components return exactly one DOM element. Just like in HTML, everything has to have 1 parent DOM element, they can't have 2 parent DOM elements. For example, if we wanted to return a pair of h1s as in "<h1></h1> <h1></h1>", this won't work. We'll get the nasty error that JSX elements must be wrapped in an enclosing tag, so if we want to return multiple, we just have to wrap them in a div, like so as in "<div><h1></h1> <h1></h1></div>" Now it'll work again and we'll have 2 "h1"s. This was just for an example. Another thing is we can import dynamic information very easily, we can create a "const" with our name as in "const = 'Marco'; " and then anything in curly braces { } in the JSX portion of our file (emphasis on the JSX portion, it won't work outside of it) but anything in curly braces will just execute as normal JavaScript, as in "<h1>It's {}!</h1>", we can also do "{3+2}" and it will result in 5. We can also do a self-executing anonymous function, we don't know why we'd want to do that, but we can see it executes the function. If we do need logic, this is not proper place to do it. Generally, if we need basic logic, we can do it in the render method. So say, we can do some sort of self-executing anonymous function "var val = (function(){})" so say maybe "var val = getVal();", something like that is totally fine, and then we can print {val}. Or if we have a little bit more logic and we want to keep our render method clean, which is always a good idea, outside of the render method, we could do "getVal(){return 'Will';}", we could do a method on our class and then we could do in the render, "render(){ return(<h1>It's{this.getVal()}!</h1>);}" and then whatever getVal returns, will be returned into the template, so we're going to return 'Will;' again, and yippee "It's Will" again. We can also pass values into them, as in "render(){ return(<h1>It's{this.getVal(1)}!</h1>);} and "getVal(val){return 'Will';}" and we can return "getVal(val){return 'Will' + val;}" and the page will redner "It'sWill1!", and we get the point. They're basically class methods and we can invoke them. Last but not least, we can actually use a constructor method, since it is a JavaScript class, we can do a constructor method, as in "constructor() {super(); this.name = 'Will';}", the only thing we have to remember is that we have to call "super();" on the first line , and then we can simply just access this.name as in "render(){ return(<h1>It's{this.name}!</h1>);}", It's Will. So there we go, that's our basic component introducion.
#3 COMPOSING MULTIPLE COMPONENTS
So our client.js really shouldn't and doesn't need to have our "Layout" in it. So let's go ahead and cut that out of the picture, and our first step is to make it into its own component. So we'll make a new folder in the JS directory called "components" and in that "components", we're going to make a new file and paste that in and we'll save this as "Layout.js" and we're going to capitalize it, because as a standard rule-of-thumb we always want Components to have a capital letter, capitalized. We're going to import "react", we don't need "react-dom", so now we have our Layout, all we have to do is export our class that we have created, as in "export default class Layout extends React.Component..."so we can require it now into client.js as in "import Layout from './components/Layout';" So now we've got exporting Layout, and importing Layout, let's save and make sure it still works, and it does.       So let's go ahead and create the rest of our page now. So we have our Layout.js and we're going to go ahead and create a header and a footer, we're gonna go ahead and just copy the code in Layout.js, and then save it in a new file and name it Header.js, we'll change "export default class Layout extends React.Component..." to "export default class Header extends React.Component..." and we'll get rid of this whole constructor function, and we'll return a header tag. We'll just leave that there for now. We'll go ahead and import that into our Layout as in "import Header from './Header'" We'll go ahead and get rid of the constructor as well, and we're returning our 1 div as in "render(){return(<div><Header/></div>);" and again, it's capitalized and we can use it straight there in the HTML because it's a Component. Components can render anywhere in the HTML that you want. And again, the reason we capitalize Components as a standard, is because they're a constructor, the Header's not a rendered DOM element yet, it just has the capacity to render out a DOM element, whenever we print it. So we can do this and this and this as in "<div><Header/><Header/><Header/></div>" and it's going to render out 3 completely different elements. Later on we'll get into how to pass unique details and information into each one of them and make them actually render into 3 different looking headers. Another option if we want to render multiple versions of something is to call it a list, do an array and make an array of three DOM elements, as in "var list = [<Header/>,<Header/>,<Header/> ];", which is very useful for something like a list full of <li>s., and then we can just go {list} as in "render(){return(<div>{list}</div>);}", and JSX is smart enough to know that that is an array of three Components, so let's render each one as Components. So that's what we would do.    So let's go ahead and undo some of the Layout so we just have a <Header/>. Now we'll go ahead and make our Footer by copying the code of Header.js and then changing "export default class Header extends React.Component..." to "export default class Footer extends React.Component" and changing the header tags to footer tags. And now our Layout.js can import Footer as well. ** in Layout.js, I might've thought that the Header.js file came first before Footer.js, however, we're just keeping them alphabetized, so in this case, the Footer.js comes first before Header.js** So now on Layout.js, we can print our <Header/> and our <Footer/> as in "  render(){return(<div><Header/><Footer/></div>);}" Let's see what we got, it should render out, excellent. We're good to go, and then we can create a body and so on and so forth. So this is kind of a standard layout here, sometimes people will do a "pages" folder, that has all of our very top-level components, which in this case would be "Layout", and then "components" would be everything that lives within the page. So that's an option, you can have your Layout living components, or you can have a separate "pages" folder, or sometimes that would be called "routes" and then, inside of these like we said are our top-level components. And then if a Component has a Component within it, then the standard way is we'll probably just want to create a new folder. So let's say this header actually has a title in it, let's go ahead and create a new folder, we're going to call it Header, so any Component within the Header Component, is going to go inside it. *I need to review this part a bit more.* My interpration is that you could have a Component, e.g., Header which has its folder, and then you can have another Component within it as a file, e.g., Title.js, and then you can have the Header folder summon the Title component by importing Title as in "import Title from './Header./Title;' and then render the Title Component, so that the Header Component can summon the Title Component and will also incorporate whatever the Title Component has within the Header Component. So if the Title Component has a <h1>Welcome</h1> inside of it, the Header can simply render the Title Component and the <h1>Welcome Aboard!</h1> tag will be rendered. So now we should have a 'Welcome Aboard', that's the header, with a Title h1 inside of it and there's the footer. Upon inspecting, let's go ahead and just look real quickly at the DOM that was created from that, heres's my app, and then there's an h1 getting printed, and there's a footer getting printed, so even though header is returning the Title, there are no extra DOM elements that get added, unless we wrap a div around it. Once we wrap a div around  it, there's our header component and there's our header div and that's how it all works out. ** A simple explanation from what I saw from Bucky: Also, a render can only essentially display 1 parent element as well. So if we want to display multiple components, we have to wrap them in a div parent element.** 
#4 STATE VS PROPS & APPLICATION DATA:
So there are basically two ways that data gets handled in REACT. It gets handled through state and it gets handled through props. (There's a third way, context, but it's not stable yet and is too new and we won't go over it until later on in the course and we'll leave it alone for now.). So let's look at state first, and as we go we'll end up using Props much much more, but State is also used by a lot of people in some ways as well. State is basically available through "this.state" which, by default, is null, "this.state === null;" So by default,  State will be null. And then we can set it, so let's go ahead and make a constructor method and the only place we want to set State this way, is in the constructor method, we literally just set our initial State, as in  "constructor(){ super(); this.state = {name: "Will"};}" And then we can access this by entering this.state.name as in "render(){return(<div>{this.state.name}<Header/><Footer/></div>);}" So we see it's kind of a similar concept to what we did earlier, but this is the proper way to do it. So we see that there we go, the name Will is printer on top. Now What's Really Cool About State, Is That Whenever State Changes On A Component, The Component Will Automatically Re-Render And Update The DOM If There Are Any Changes, If There Are No Changes, The DOM Won't Get Touched At All. That's The First Big Amazing Thing That React Brought To The World, Is It Manages A Virtual DOM For Us, So Whenever React Renders Out All The Components, The Component Tree Is What It's Called, It Renders The Layout, The Header, The Footer, Everything, Then It Looks For Changes From The Virtual DOM To The Actual DOM, If There Are Changes, It Will Update Only The Affected Nodes, In The Most Efficient Way. If There Are No Changes At All, It Doesn't Even Touch The Webpage. This Is Great Because JavaScript Is Really Really Fast, But the DOM Is Really Really Slow, Whenever We Have To Actually Go To The DOM And Update Elements, That's The Slow Part Of Any Webpage. So, By Having A Virtual DOM, Where Everything Is Updated Behind The Scenes, And Only Changed In The Real DOM If There Are Differences, That Allows Our Applications To Become Extremely Fast. So let's go ahead and look at how we change the state. We can go ahead into the render method and do a setTimeout, let's pretend after 1 second, the user did some action and we want to change our state, so we "this.setState", which is the one method that we need to know with State. And we just give it a new state, in this case, "Bob", as in "render(){setTimeout(() => { this.setState({name:"Bob"});},1000)return(<div>{this.state.name}<Header/><Footer/></div);}". Now after 1 second, the state get schanged and Will gets updated to Bob.So when setState gets fired, it will update the state, it will automatically re-render, and again if there are any changes, it will print out. Let's actually show us what React is doing behind the scenes:In the console on Chrome, we hit the escape key, and that gives us these rendering options, we can enable paint flashing, so now, the screen will flash green whenever a node gets changed (didn't really get to do this because the rendering options menu did not open); we can see first that the whole screen flashes green, and then and 1 second later, Will changes to Bob, so that was the change and nothing else. Even though we did a complete render of the header, the footer, the entire layout, the only actual DOM element that changed, was the one that contained state.name, so that's all that React updated. We're gonna go ahead and inspect this, and we can see that it autmatically made a <span> for Bob. That's the only that will change. Let's go to refresh again, it flashes green and the only thing that flashed changed, and it was this <span> for Bob. So React Automatically Manages The DOM Manipulation For Us. This Is One Of The Best Things To React. Because if you've done Backbone.JS at all, you understand that there's always this question of: "Hmmm...At what point should I update the DOM, and when I do, who should update that? Should the list component update the whole list and re-render the whole list? Or should just each list-item manage the rendering itself?" Basically React Takes All Of That Out And Says We're Going To Re-render Everything, All The Time, On Any Change, But We're Only Going To Do It In JavaScript, And We're Only Going To Touch The DOM If Something Has Actually Changed That Would Reflect In A Visual Way. So That's The Great First Thing About React. And that's how we'd manage State. So the kind of mentally behind State is that it only gets used if a Component has an internal value that only affects that component and doesn't affect any of the rest of the app. If there's something that affects layout and affects absolutely nothing else, State may be appropriate. Aside from that, we want to use Props, and Props are injected into every other component. Let's show how Props work. We'll get rid of all this State (the constructor, 1 sec, etc.,  and the {this.state.name} in between the divs), get rid of "{this.state.name}" and we're going to now inject a Prop into the <Header/>. Let's say var title, well, we'll do a "const title = 'Welcome Will!'" and now in our header, we're actually goint to inject a title, as in "<Header title = {title}/>" So we basically created a prop just like we would on an actual DOM element, we'd give it a prop, and now if we go to our header.js, we can access this.props, let's do "console.log(this.props)" as in "render(){console.log(this.props);return(<div><Title/></div>);}" in header.js and see what we're getting here. Let's look at our console, and we can see that we have a title of "Welcome Will!" so it automatically gets converted into an object. We could give this multiple props, we could give it a {name="Some thing"} we'll just give it a brand new string right there, we could see that "name is something" and title is "Welcome Will!" down here. So that's how we inject props into things, we could give it a second "<Header/>" and we could give its title something else as in "<Header title={title}/> <Header title={"Other Title"}/>" And again, that's actually how we're going to create multiple versions of a <Header/> that are different. So let's make that header now, use a different title. So in header.js, we take out the console.log and we're actually going to just continue props right on over into <Title/>, we're going to go "<Title title = {this.props.title}/>" So now, we're just going to continue passing that straight on through to title.js, and title.js will actually make use of it, as in "render(){return(<h1>{this.props.title}</h1>);" *This was very confusing to me, because I wasn't sure how the other title knew to display "Other Title" instead of just "Welcome!", but I think I know why now, and what I think is the reason behind it is that the {title} from "<Header title ={title}/>" is a prop from "const title = 'Welcome!'", while {"Other Title"} is a property, or prop invoked from "this.props.title", so in actuality, both props are being invoked in their appropriate places.* There we go, so now we have "Welcome Will!" and we have "Other Title", they've rendered through. Our Layout.js has passed in a different title to each header, our Header.js is just transparently passing them through to the title, only the title props, and then our Title.js is actually receiving that and spitting it out. So we have a completely different header, and a completely different footer for each one. And again, let's go ahead and look at this, and now what we can do is we could, well let's go ahead and change our Layout.js here to use both state and title. Let's type "constructor(){super();this.state = {title: "Welcome",}}" and we comment out "const title = 'Welcome Will!';" and pass in "this.state.title" on the top header as in "<Header title = {this.state.title}/>" So then again our setTimeout will be 2 seconds, as in "render(){setTimeout(() =>{this.setState({title:"Welcome Will!"});}, 2000);..." We're going to change our state, basically changing from "Welcome!" to "Welcome Will!" after 2 seconds. Let's go ahead back to these elements in the console and let's see if the header, or the header AND the title got updated, let's refresh, and we can see that 2 seconds in, only the h1 changed, that's because even though our header component received an update, our header component received a new prop, it rendered out the exact same div, no changes, so it didn't re-render this div to the DOM, then it re-rendered a child component of title, THAT changed, the DOM looks different for the h1 that it renders, so it updated the h1 and the h1 ONLY. Again, once we get this concept, It's Really Monumentally Huge, No Matter How Many Components Change, We're Only Going To Update The DOM With The Actual Element Changes That Got Created When The Entire Tree Rendered. So there we go, those are the basics on how we manage data within our components. 
 #5 JAVASCRIPT EVENTS & DATA CHANGES IN REACT:
 Now that we know how to manage data in a React application, let's look at actually binding events, interacting with user inputs, and changing that data real-time. So let's say we want to add an input that's going to allow us to change this title as we type. So the first thing we're going to want to do is let's head over to that header.js, and add an input, save it, that'll update, and let's get rid of this other header in layout.js  that we absolutely don't need anymore. So then as this gets updated, as this header input gets typed in, we're going to want to take that change, we're going to want to trigger some kind of event on the layout that says, hey, update your state, we want a new title. That title will then get passed into the header and the whole rendering process will begin because the state changed. So the goal is we've got to get this state to change. So let's go ahead and make a changeTitle method as in "changeTitle(){}", and then this will receive a value, as in "changeTitle(title){}", so"this.setState({title:"Welcome Will!"})" and because we're receiving title here, we can actually use ES6 and just go "{title}"" which is the same thing as "({title:title})" so it just cleans things up as in "changeTitle(title){this.setState({title});}" Thank you ES6. So there we go, let's get rid of "setTimeout(() =>{this.setState({title:"Welcome Will!"})}, 2000);..." We don't need that anymore, and now, how will changeTitle fire? Well we're actually going to pass that in as a prop to header, as in "<Header changeTitle={this.changeTitle} title = {this.state.title}/>" Now, one thing that's Very Important is that when passing functions or methods around, you always want to bind them to this, as in ".bind(this)" as in "<Header changeTitle={this.changeTitle.bind(this)} title = {this.state.title}/>" in Layout.js. If we don't do ".bind(this)", then it's going to execute in the context of whatever's calling it. So let's say we pass a changeTitle as is in layout.js, and then header.js later says, "this.props.changeTitle" as in "render(){this.props.changeTitle();...", because remember it got passed in as a prop, and that's basically the same as calling it there, as in " changeTitle(title){this.setState({title});}" on the header.js component instead of the layout.js component. Now it'll "setState({title})"" on our header.js component, and our header.js component doesn't do anything with that, because nowhere in header.js is it looking for "this.state", so that "changeTitle(title){this.setState({title});}" just failed silently, it didn't throw an error and absolutely nothing happened so it's very important that you always ".bind(this)", so now no matter who calls, this "this.changeTitle" functionm, it's going to fire on the Layout.js component (or wherever file the original function was in, in this case in the Layout.js component), as in "changeTitle(title){this.setState({title});}", so that's Very Important, that has bit him more times than he can imagine, and sometimes it can take you alittle while to figure out exactly why your app is not working. So there's changeTitle, and then let's go here into header.js, you can see it automatically is changing  our title as in "render(){this.props.changeTitle("newTitle");", so right away when it renders it's going to automatically change to "newTitle", but we want this to happen whenever the user types in our input, so that's very simple, we just add onChange event, as in "<input onChange={this.handleChange.bind(this)}/>", again, bind this, because we always have to make sure that it's bound to the right context. So whenever the user input receives a change event, it's going to call on our handleChange as in "export default class Header extends React.Component{ handleChange(e){  }..." and that handleChange receives a JavaScript event, just like a normal event in JQuery or vanilla JavaScript would, so you can make the onChange in "<input onChange={this.handleChange.bind(this)}/>" as "onChange", "OnClick", "OnBlur", etc., basically every type of event you'd expect. So onChange, it's going to fire this handleChange(e) function, and all we're going to do is go this.props.changeTitle as in "handleChange(e){this.props.changeTitle();}" Did we call it changeTitle or updateTitle on Layout.js, it's changeTitle. So let's go into changeTitle in header.js, let's actually get that title out of the element, by typing const title = e.target.value as in "handleChange(e){ const title = e.target.value; this.props.changeTitle();}" So "e.target" is the element that's receiving the onChange, so that's our input right there that will be giving it, we're just getting that value out, so we've got our title, let's pass it onto changeTitle as in "this.props.changeTitle(title);", layout.js is going to fire changeTitle, which sets our state, and as soon as that state changes, the entire React tree does a re-render and if there are any changes, they can be displayed. Let's test it to see if it works. Awesome! Our title changed! Excellent! That's working great! The only change we want to make is we want this to say "Welcome Aboard!" by default. We want this to be two-way bound to the state of the title. So that's a very easy change. We simply go into header.js and we make the value of input "this.props.title" as in "<input value={this.props.title} onChange={this.handleChange.bind(this)}/>" So now by default, our value's going to be whatever the title is. And there we go! What just happened is that we actually added that exclamation point, handleChange fired, exactly the same thing, state got updated, the whole tree re-rendered, and now our header actually re-rendered, the input actually got its value dynamically updated to be whatever the new value was. So if we were to change it to value, but we never added an onChange, as in just "<input value = {this.props.title}/>" nothing else would happen, no matter how many keys we hit, evertime there's a re-render, it re-renders the value to be "{this.props.title}", which has not changed, so that's another thing that can be frustrating if we're not sure what's going on with React. Whenever you're binding a value, you also want to set up a changeListener for that, so that it actually changes when the value changes. So we hope by now, we've been able to get a sense of how React's ecosystem works. Basically, we've created an app that has data living only in one place, which is a great thing, because this has enabled us to make really "simple" components. This header.js doesn't really care where the data comes from, or what the data is, it just knows, it's gonna pass title in here, as in "<Title title={this.props.title}/>"  and whenever this input changes, as in "input value={this.props.title} onChange={this.handleChange.bind(this)}/>", it's gonna call the prop that was handed to it, changeTitle, it doesn't care what it does, it just knows that this is its job. Our title component is even "simpler", it just renders whatever you give it, as in "<h1>{this.props.title}</h1>", it's not aware of the data, it doesn't care about the data, we could move this data to a completely different application, if we wanted to, the data could come from a completely different place, it doesn't care. So we get much more re-usability out of our components, and we get much more stability. Our data only lives on Layout.js right now, and it's just, whenever the data changes, we re-render the entire application, and we update the DOM, if there are any changes. It makes our application development much simpler, because we don't have to care about near as many moving parts, that's part of the Beauty Of React. We're going to go ahead and leave Basic React here. In the next series, we're going to move more into some patterns, of how we actually deal with applications, and how we deal with routing, and a lot of other great things. LEFT OFF AT START OF #6, REACT ROUTER & INTRO TO SINGLE PAGE APPS WITH REACTJS
 THE NEXT PART, #6 AND MOVING FORWARD, IS MORE IN-DEPTH, SO I'M CREATING A NEW REPO FOR IT. 