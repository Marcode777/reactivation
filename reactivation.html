<!-- #1 REACTJS WORKSPACE SETUP   
webpack: Before we used to have to make separate files and then load them onto the html separately on their separate script tags. Now it has evolved into module loading systems. 
So beforehand we install Node.JS, then npm init to get a package.json going and then install webpack. Then npm install -g webpack. Then create webpack.config.js, and inside can be a sample start-up webpack. If it's production, if so then we'll run minification, and we won't do source-mapping, if it's not production, then we'll consider it debugging mode and we'll do inline sourcemaps. Our entry point is, in this case, ./js/scripts.js, this is where we're starting off. Our output is the /js folder.



***Excerpt of advice from YouTube: The easiest way to set up your project is to make a directory tree structure the way it's displayed on his sublime text editor.  If you can't make out the structure, do this:  create your project folder; inside the project folder create a 'src' folder; inside the 'src' folder, create a 'js' folder.  You will now create four files.  Create two empty files,  'package.json' and a 'webpack.config.js', and place them at the top level of your project folder.  Create another empty file, 'index.html' and put it inside your 'src' folder.   Create the last file, 'client.js' and place it inside 'js' folder.

Now advance the video to 3:04 and simply type what you see into your 'client.js' file.  As for the contents of the other three files, you can go to the github repository he listed in the  comments under the video.  Specifically, you will need to access the '1-basic-react' folder to get the contents of each the other three files.  

After you have set up your folders and copied the files, you run 'npm install', then 'webpack',  and the rest of the folders and files will be automatically installed.  At this point you can advance to '2:38' in  the video and continue following along.  Hope this helps you and anyone else who might have the same question.ï»¿***-->


<!--the contents in webpack.config.js are from https://github.com/learncodeacademy/react-js-tutorials/blob/master/1-basic-react/webpack.config.js
the contents from package.json are from https://github.com/learncodeacademy/react-js-tutorials/blob/master/1-basic-react/package.json, the only thing I changed was the name, to "reactivation", for my own work-->
<!-- before, when i ran "npm install", then "webpack", it said "bash webpack command not found" I realized that I had to first "npm install webpack" first, and then run "webpack" and this seemed to work-->
<!-- I can continue onto 2:38 of vid #1 now-->

<!-- so we also ran "webpack -- watcher", which watches our code for changes and as we save, it'll continue to do that. So if you change something in the code and save, it will retranspile everything.-->
<!-- after the comments in client.js, we're back here. So let's wrap up our workspace and our workflow here, obviously we'll want to get some kind of live reload happening, and webpack dev server is kind of the standard way of doing that. So let's go ahead and "npm install -S webpack-dev-server" and let's go ahead and get maybe an npm run dev command going. Well let's also install webpack dev server globally as well, by typing "npm install -g webpack-dev-server" which we won't be using, but we'll do it for now. Let's get webpack-dev-server installed globally so we have the webpack server command. Actually we need to give it a content base. Since we don't want to serve this folder that we're in right now, we want to serve the source folder, we're just going to go content base is source, so we'll type "webpack-dev-server --content-base src" So that way it's going to serve "index.html" as the root of that. So now we can actually go to "localhost 8080". And there we go, we have "localhost8080" working, let's get a split-screen going on, but we don't have live reload up yet. We can do two things, by default we can the iframe mode, which is "localhost:8080/webpack-dev-server/index.html" and you'll see a loader bar up there, it'll automatically load your app into a brand new iframe everytime, so let's change the text, it's going to recompile and reload, so that's kind of smooth. So if that works for us straight out of the bag, that's great. Another thing we can do is we do the inline flag, and hot flag, hot will help it do inline a little bit better as in the console type "webpack-dev-server--content-base src --inline --hot". So if we have inline and hot, then we're not going to have that top, and it's just going to automatically do it inline which is basically live reload. So we're going to go ahead and take that command and we're just going to go ahead and make - that's kind of a mouthful to type everytime, so let's go ahead and add that to our package.json, let's go to our scripts and make it "dev" as in "dev": "webpack-dev-server --content-base src --inline --hot", so there we go, npm run dev now, will run this command for us.
"npm run dev" gets our full webpack-dev-server running, and we're up and rolling! The only the other thing we're going to change is, we don't want to have all our developers have to do an npm install global of webpack-dev-server, so we're actually going to reference the node module's bin, you can see that it installs a command of webpack-dev-server, it installs an executable webpack-dev-server as well, so we can actually execute this command in "dev": "webpack-dev-server --content-base src --inline --hot", with ./ as in "dev": "./node_modules/.bin/webpack-dev-server --content-base src --inline --hot", . That's taken care of by our package now as in "webpack-dev-server": "^1.15.0" in package.json, so now we can actually uninstall, as in "uninstall -g webpack-dev-server", we're going to uninstall that one as in "npm uninstall -g webpack-dev-server", and now npm run dev will still work, because we're referencing the one that's in our repository. So that's a little bit of a cleaner way. At first, with NodeJS, we always had everybody install a global for everything. And now we just think it's much cleaner to install it, with your package, install it locally to your app, that way the exact version you need for your app is installed in your app folder, and then you run it with a node script, npm run dev, or npm start, are kind of the standard choices that you would pick. So there we go, that's running, that's our setup for React.
#2 REACTJS COMPONENTS AND RENDERING 
Again, everything in React is a component. And components return exactly one DOM element. Just like in HTML, everything has to have 1 parent DOM element, they can't have 2 parent DOM elements. For example, if we wanted to return a pair of h1s as in "<h1></h1> <h1></h1>", this won't work. We'll get the nasty error that JSX elements must be wrapped in an enclosing tag, so if we want to return multiple, we just have to wrap them in a div, like so as in "<div><h1></h1> <h1></h1></div>" Now it'll work again and we'll have 2 "h1"s. This was just for an example. Another thing is we can import dynamic information very easily, we can create a "const" with our name as in "const = 'Marco'; " and then anything in curly braces { } in the JSX portion of our file (emphasis on the JSX portion, it won't work outside of it) but anything in curl braces will just execute as normal JavaScript, as in "<h1>It's {}!</h1>", we can also do "{3+2}" and it will result in 5. We can also do a self-executing anonymous function, we don't know why we'd want to do that, but we can see it executes the function. If we do need logic, this is not proper place to do it. Generally, if we need basic logic, we can do it in the render method. So say, we can do some sort of self-executing anonymous function "var val = (function(){})" so say maybe "var val = getVal();", something like that is totally fine, and then we can print {val}. Or if we have a little bit more logic and we want to keep our render method clean, which is always a good idea, outside of the render method, we could do "getVal(){return 'Will';}", we could do a method on our class and then we could do in the render, "render(){ return(<h1>It's{this.getVal()}!</h1>);}" and then whatever getVal returns, will be returned into the template, so we're going to return 'Will;' again, and yippee "It's Will" again. We can also pass values into them, as in "render(){ return(<h1>It's{this.getVal(1)}!</h1>);} and "getVal(val){return 'Will';}" and we can return "getVal(val){return 'Will' + val;}" and the page will redner "It'sWill1!", and we get the point. They're basically class methods and we can invoke them. Last but not least, we can actually use a constructor method, since it is a JavaScript class, we can do a constructor method, as in "constructor() {super(); this.name = 'Will';}", the only thing we have to remember is that we have to call "super();" on the first line , and then we can simply just access this.name as in "render(){ return(<h1>It's{this.name}!</h1>);}", It's Will. So there we go, that's our basic component introducion.
#3 COMPOSING MULTIPLE COMPONENTS
So our client.js really shouldn't and doesn't need to have our "Layout" in it. So let's go ahead and cut that out of the picture, and our first step is to make it into its own component. So we'll make a new folder in the JS directory called "components" and in that "components", we're going to make a new file and paste that in and we'll save this as "Layout.js" and we're going to capitalize it, because as a standard rule-of-thumb we always want Components to have a capital letter, capitalized. We're going to import "react", we don't need "react-dom", so now we have our Layout, all we have to do is export our class that we have created, as in "export default class Layout extends React.Component..."so we can require it now into client.js as in "import Layout from './components/Layout';" So now we've got exporting Layout, and importing Layout, let's save and make sure it still works, and it does.       So let's go ahead and create the rest of our page now. So we have our Layout.js and we're going to go ahead and create a header and a footer, we're gonna go ahead and just copy the code in Layout.js, and then save it in a new file and name it Header.js, we'll change "export default class Layout extends React.Component..." to "export default class Header extends React.Component..." and we'll get rid of this whole constructor function, and we'll return a header tag. We'll just leave that there for now. We'll go ahead and import that into our Layout as in "import Header from './Header'" We'll go ahead and get rid of the constructor as well, and we're returning our 1 div as in "render(){return(<div><Header/></div>);" and again, it's capitalized and we can use it straight there in the HTML because it's a Component. Components can render anywhere in the HTML that you want. And again, the reason we capitalize Components as a standard, is because they're a constructor, the Header's not a rendered DOM element yet, it just has the capacity to render out a DOM element, whenever we print it. So we can do this and this and this as in "<div><Header/><Header/><Header/></div>" and it's going to render out 3 completely different elements. Later on we'll get into how to pass unique details and information into each one of them and make them actually render into 3 different looking headers. Another option if we want to render multiple versions of something is to call it a list, do an array and make an array of three DOM elements, as in "var list = [<Header/>,<Header/>,<Header/> ];", which is very useful for something like a list full of <li>s., and then we can just go {list} as in "render(){return(<div>{list}</div>);}", and JSX is smart enough to know that that is an array of three Components, so let's render each one as Components. So that's what we would do.    So let's go ahead and undo some of the Layout so we just have a <Header/>. Now we'll go ahead and make our Footer by copying the code of Header.js and then changing "export default class Header extends React.Component..." to "export default class Footer extends React.Component" and changing the header tags to footer tags. And now our Layout.js can import Footer as well. ** in Layout.js, I might've thought that the Header.js file came first before Footer.js, however, we're just keeping them alphabetized, so in this case, the Footer.js comes first before Header.js** So now on Layout.js, we can print our <Header/> and our <Footer/> as in "  render(){return(<div><Header/><Footer/></div>);}" Let's see what we got, it should render out, excellent. We're good to go, and then we can create a body and so on and so forth. So this is kind of a standard layout here, sometimes people will do a "pages" folder, that has all of our very top-level components, which in this case would be "Layout", and then "components" would be everything that lives within the page. So that's an option, you can have your Layout living components, or you can have a separate "pages" folder, or sometimes that would be called "routes" and then, inside of these like we said are our top-level components. And then if a Component has a Component within it, then the standard way is we'll probably just want to create a new folder. So let's say this header actually has a title in it, let's go ahead and create a new folder, we're going to call it Header, so any Component within the Header Component, is going to go inside it. *I need to review this part a bit more.* My interpration is that you could have a Component, e.g., Header which has its folder, and then you can have another Component within it as a file, e.g., Title.js, and then you can have the Header folder summon the Title component by importing Title as in "import Title from './Header./Title;' and then render the Title Component, so that the Header Component can summon the Title Component and will also incorporate whatever the Title Component has within the Header Component. So if the Title Component has a <h1>Welcome</h1> inside of it, the Header can simply render the Title Component and the <h1>Welcome Aboard!</h1> tag will be rendered. So now we should have a 'Welcome Aboard', that's the header, with a Title h1 inside of it and there's the footer. Upon inspecting, let's go ahead and just look real quickly at the DOM that was created from that, heres's my app, and then there's an h1 getting printed, and there's a footer getting printed, so even though header is returning the Title, there are no extra DOM elements that get added, unless we wrap a div around it. Once we wrap a div around  it, there's our header component and there's our header div and that's how it all works out. ** A simple explanation from what I saw from Bucky: Also, a render can only essentially display 1 parent element as well. So if we want to display multiple components, we have to wrap them in a div parent element.** 
#4 STATE VS PROPS & APPLICATION DATA:
So there are basically two ways that data gets handled in REACT. It gets handled through state and it gets handled through props. (There's a third way, context, but it's not stable yet and is too new and we won't go over it until later on in the course and we'll leave it alone for now.). So let's look at state first, and as we go we'll end up using Props much much more, but State is also used by a lot of people in some ways as well. State is basically available through "this.state" which, by default, is null, "this.state === null;" So by default,  State will be null. And then we can set it, so let's go ahead and make a constructor method and the only place we want to set State this way, is in the constructor method, we literally just set our initial State. This state = 
